# -*- coding: utf-8 -*-
"""Assignment1_Smirnova_G6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-5uE83ak9wbezA5BfLFuC6OMOBEfbX7i

# Part 1

<img src="https://www.mdpi.com/entropy/entropy-17-06289/article_deploy/html/images/entropy-17-06289-g001.png" width="400">

Constructed physical equation:

$$ma = -bv - kx + F_{ext}$$

Constructed ODE:

$$m\ddot x+b\dot x + kx= F_{ext}$$

Find its state space representation:

$$\dot x = Ax + Bu$$

Solution:

$$x = \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = 
\begin{bmatrix} x \\ \dot x \end{bmatrix}$$

$$\dot x = \begin{bmatrix}\dot x_1 \\ \dot x_2 \end{bmatrix} = 
\begin{bmatrix} \dot x \\ \ddot x \end{bmatrix}$$

$$\dot x_1 = x_2$$
$$\dot x_2 = -\frac{k}{m}x_1 - \frac{b}{m}x_2 + \frac{1}{m}F_{ext}$$

Final State Space Model:
$$\begin{bmatrix} \dot x_1 \\ \dot x_2 \end{bmatrix} = 
\begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{b}{m}\end{bmatrix}
\begin{bmatrix} x_1 \\ x_2 \end{bmatrix} + \begin{bmatrix} 0 \\ \frac{1}{m} \end{bmatrix}F_{ext}$$
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import math

# set the coeffitients
n = 2                               # degree of the polynomial
#a = np.random.rand(n+1)             # coefficients: [a0 a1 a2] = [k b m]
a = np.array([19.6, 0, 4])
a = np.flip(a)                      #to be pedantic with indicies in the notation
print("Our coeffitients a are:", a)

# normalize the coeffitients
a_norm = a[1:] / a[0]               # all coeffitients divided by m
b_norm = 1 / a[0]                   # 1 divided by m
print("Our coeffitients a and Fext are:", a_norm, b_norm)

# determine matrix A
A = np.zeros((n, n))                 # state matrix
A[0 , 0:] = -a_norm
A[1:, 0:(n-1)] = np.eye(n-1)
print("Our matrix A:")
print(A)

# determine matrix B
B = np.zeros((n, 1))                   # state matrix
B[0, 0] = b_norm
B[1:, 0] = 0
print("Our matrix B:")
print(B)

# define F(t)
def define_b(t):
    b = np.array([10])
    #b = np.array([math.sin(t)])       # for example F(t) = sin(t). Here you can put the number instead of sin(t) and see that vibrations damp
    return(b)

# solve ODE
def LinearODE(x, t):
    dx = np.zeros(n)
    dx[0] = -a_norm.dot(x) + define_b(t)/a[0]
    dx[1:] = x[0:(n-1)]
    return dx

# solve state space
def StateSpace(x, t):
    return A.dot(x) + B.dot(define_b(t))

#time = np.linspace(0, 10, ) #divide the segment on 1000 parts
time = np.arange(0, 10, 0.1);
x0 = np.random.rand(n)  # initial state
print("x0 = ", x0)

solution = odeint(StateSpace, x0, time)  

#graph the solution of the state space model
plt.subplot(122)
plt.plot(time, solution[:, 0], 'b')
plt.xlabel('time')
plt.ylabel('x(t)')
plt.grid()
plt.show()

"""# Part 2

The physical equation of the system (rotational motion): 
$$ I\alpha = -mglsin\theta - 2kaxcos\theta$$
$$ I\alpha = -mgl\theta - 2ka^2\theta$$

Constructed ODE:

$$ml^2\ddot \theta + mgl\theta + 2ka^2\theta = 0$$

Find its state space representation:

$$\dot x = Ax + Bu$$

Solution:

$$x = \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = 
\begin{bmatrix} \theta \\ \dot \theta \end{bmatrix}$$

$$\dot x = \begin{bmatrix}\dot x_1 \\ \dot x_2 \end{bmatrix} = 
\begin{bmatrix} \dot \theta \\ \ddot \theta \end{bmatrix}$$

$$\dot x_1 = x_2$$
$$\dot x_2 = -(\frac{g}{l}+\frac{2ka^2}{ml^2})x_1$$

Final State Space Model:
$$\begin{bmatrix} \dot x_1 \\ \dot x_2 \end{bmatrix} = 
\begin{bmatrix} 0 & 1 \\ -(\frac{g}{l}+\frac{2ka^2}{ml^2}) & 0\end{bmatrix}
\begin{bmatrix} x_1 \\ x_2 \end{bmatrix}$$
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import math

# set the coeffitients
n = 2                               # degree of the polynomial
a = np.random.rand(n+1)             # coefficients: [a0 a1 a2] = [(mgl+2ka^2) 0 ml^2]
a[1] = 0
a = np.flip(a)                      #to be pedantic with indicies in the notation
print("Our coeffitients a are:", a)

# normalize the coeffitients
a_norm = a[1:] / a[0]               # all coeffitients divided by m
print("Our coeffitients a are:", a_norm)

# determine matrix A
A = np.zeros((n, n))                 # state matrix
A[0 , 0:] = -a_norm
A[1:, 0:(n-1)] = np.eye(n-1)
print("Our matrix A:")
print(A)

# solve ODE
def LinearODE(x, t):
    dx = np.zeros(n)
    dx[0] = -a_norm.dot(x)
    dx[1:] = x[0:(n-1)]
    return dx

# solve state space
def StateSpace(x, t):
    return A.dot(x)

time = np.linspace(0, 30, 60) #divide the segment on 1000 parts
x0 = np.random.rand(n)  # initial state
print("x0 = ", x0)

solution = {"ODE": odeint(LinearODE, x0, time), "SS": odeint(StateSpace, x0, time)}  #dictionary

#graph the solution of ODE
plt.subplot(121)
plt.plot(time, solution["ODE"])
plt.xlabel('time')
plt.ylabel('x(t)')

#graph the solution of the state space model
plt.subplot(122)
plt.plot(time, solution["SS"])
plt.xlabel('time')
plt.ylabel('x(t)')
plt.show()