# -*- coding: utf-8 -*-
"""Updated_Lab12_G6_Smirnova.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17Oj2dZdN6VpdDMmi1_fva9KheOer1Dmu

***Task 1:***

Simulate simple pendulum with known mass and length. Given parameters: mass = 1kg, length = 2m.

Method used to solve the equation: odeint().
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.integrate import odeint
from numpy import random

n = 2  # degree of the polynomial
time = np.linspace(0, 10, 101)
y0 = [0, 0]  # initial state

mass = 1 
l = 2  # length
g = 9.8 

u = np.empty([101,])
for i in range(0, 100):
  u[i] = random.uniform(0, 5.0)  # u(t) = uniformly distributed random float value from the range [0, 5]

def u_t(t):
  index = int(t*10)
  return u[index]

# theta''(t) + b*theta'(t) + c*sin(theta(t)) = 0
# for the case with torque = 0
def pendulum(y, t, b, c):
  theta, omega = y
  dydt = [omega, -b*omega - c*np.sin(theta)]
  return dydt

# theta''(t) + b*theta'(t) + c*sin(theta(t)) = u(t)
# for the case when torque changes with time
def pendulum_torque(x, t, b, c):
  dx_dt = [0, 0]
  dx_dt[0] = x[1]
  dx_dt[1] = -b*x[1] - c*np.sin(x[0]) + u_t(t)
  return dx_dt

b = 0
c = g/l

solution = odeint(pendulum_torque, y0, time, args=(b, c))  

plt.plot(time, solution[:, 0], 'b', label='theta(t)')
plt.legend()
plt.xlabel('time')
plt.grid()
plt.show()

"""***Task 2:***

Simulate a simple pendulum with mass and length changed by a fixed value. Plot variation of the angle. Change in parameters:

mass = 1 + 1

length = 2 + 2
"""

mass_changed = 1 + 1  # mass
l_changed = 2 + 2  # length

c_changed = g/l_changed

solution_changed = odeint(pendulum_torque, y0, time, args=(b, c_changed))  

plt.plot(time, solution[:, 0], 'b', label='theta(t)')
plt.plot(time, solution_changed[:, 0], 'r', label='theta_changed(t)')
plt.legend()
plt.xlabel('time')
plt.grid()
plt.show()

"""***Task 3:***

Simulate the simple pendulum considering random input for torque u. Estimate the system parameters.
"""

from random import randint, random, uniform


m = 50  # number of measurements

measured_ang_acc = np.empty([m,])
for i in range(0, m):
  measured_ang_acc[i] = u[i]/(mass*l*l) - (g/l)*math.sin(solution[i][0]) + random()  # add little noise to measurements

y_bar = np.empty([m,])
for i in range(0, m):
  y_bar[i] = u[i]

M_bar = np.empty([m, n+1])
for i in range(0, m):
  M_bar[i][2] = solution[i][0]  # copy measurements for angle

for i in range(0, m):
  M_bar[i][1] = solution[i][1]  # copy measurements for angular velocity

for i in range(0, m):
  M_bar[i][0] = measured_ang_acc[i]  # copy measurements for angular acceleration

# calculations using the formula y_bar = M_bar * theta
# theta = [ml^2 0 mgl]
M_tr = np.transpose(M_bar)
M_mult = np.matmul(M_tr, M_bar)
M_inv = np.linalg.pinv(M_mult)
theta = (M_inv.dot(M_tr)).dot(y_bar)

l_estimated = theta[0]/(theta[2] / g)
mass_estimated = theta[0] / (l_estimated*l_estimated)

print('Actual parameters: length = {0:3.2f}, mass = {1:3.2f}'.format(l, mass))
print('Estimated parameters: length = {0:3.2f}, mass = {1:3.2f}'.format(l_estimated, mass_estimated))

"""***Task 4:***

Determine the input torque which will help in identifying the
paramters with minimum error.

By experimenting with values of input torque u(t), I concluded that the one of the best ranges for $u(t) = [1.9, 2.1]$.
"""

u = np.empty([101,])
for i in range(0, 100):
  u[i] = 1.9  # one of the best values for input torque 

measured_ang_acc = np.empty([m,])
for i in range(0, m):
  measured_ang_acc[i] = u[i]/(mass*l*l) - (g/l)*math.sin(solution[i][0]) #+ random()  # add little noise to measurements

y_bar = np.empty([m,])
for i in range(0, m):
  y_bar[i] = u[i]

M_bar = np.empty([m, n+1])
for i in range(0, m):
  M_bar[i][2] = solution[i][0]  # copy measurements for angle

for i in range(0, m):
  M_bar[i][1] = solution[i][1]  # copy measurements for angular velocity

for i in range(0, m):
  M_bar[i][0] = measured_ang_acc[i]  # copy measurements for angular acceleration

# calculations using the formula y_bar = M_bar * theta
# theta = [ml^2 0 mgl]
M_tr = np.transpose(M_bar)
M_mult = np.matmul(M_tr, M_bar)
M_inv = np.linalg.pinv(M_mult)
theta = (M_inv.dot(M_tr)).dot(y_bar)

l_estimated = theta[0]/(theta[2] / g)
mass_estimated = theta[0] / (l_estimated*l_estimated)

print('Actual parameters: length = {0:3.2f}, mass = {1:3.2f}'.format(l, mass))
print('Estimated parameters: length = {0:3.2f}, mass = {1:3.2f}'.format(l_estimated, mass_estimated))